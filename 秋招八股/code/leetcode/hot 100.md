##### 两数之和
```
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hashtable = dict()
        for i, num in enumerate(nums):
            if target - num in hashtable:
                return [hashtable[target - num], i]
            hashtable[nums[i]] = i
        return []
```
##### 两数相加
```
    def addTwoNumbers(self, l1, l2):
        dummy = ListNode(0)
        idx1 = l1
        idx2 = l2
        cur = dummy
        base = 0
        plus = 0
        while idx1 != None and idx2 != None:
            base = (idx1.val + idx2.val + plus) % 10
            plus = (idx1.val + idx2.val + plus) // 10
            cur.next = ListNode(base)
            cur = cur.next
            idx1 = idx1.next
            idx2 = idx2.next
        while idx1 != None:
            base = (idx1.val + plus) % 10
            plus = (idx1.val + plus) // 10
            cur.next = ListNode(base)
            cur = cur.next
            idx1 = idx1.next
        while idx2 != None:
            base = (idx2.val + plus) % 10
            plus = (idx2.val + plus) // 10
            cur.next = ListNode(base)
            cur = cur.next
            idx2 = idx2.next
        if plus != 0:
            cur.next = ListNode(plus)
        return dummy.next
```
##### 无重复字符的最长字串
```
    def lengthOfLongestSubstring(self, s: str) -> int:
        window = defaultdict(int)
        l, r = 0, 0
        res = 0 
        while r < len(s):
            c = s[r]
            r += 1
            window[c] += 1
            while window[c] >= 2:
                d = s[l]
                l += 1
                window[d] -= 1
            res = max(res, r - l)
        return res
```
##### 寻找两个正序数组的中位数
```
    def findMedianSortedArrays(self, nums1, nums2):
        l1, l2 = len(nums1), len(nums2)
        if l1 == 0 and l2 == 0:
            return 0
        elif l1 == 0:
            if l2 % 2 == 0:
                return (nums2[l2 // 2] + nums2[l2 // 2 - 1]) / 2
            else:
                return nums2[l2 // 2]
        elif l2 == 0:
            if l1 % 2 == 0:
                return (nums1[l1 // 2] + nums1[l1 // 2 - 1]) / 2
            else:
                return nums1[l1 // 2]
        else:
            if (l1 + l2) % 2 == 1:
                return self.findKth(nums1, nums2, (l1 + l2) // 2 + 1)
            else:
                return (self.findKth(nums1, nums2, (l1 + l2) // 2 + 1) + self.findKth(nums1, nums2, (l1 + l2) // 2)) / 2
    

    def findKth(self, nums1, nums2, kth):
        longs = nums1 if len(nums1) >= len(nums2) else nums2
        shorts = nums1 if longs == nums2 else nums2
        l = len(longs)
        s = len(shorts)
        # 1 | 2 3 4 5 | 6 7 8
        # 1 2 3
        if kth <= s:
            return self.getMedium(shorts, 0, kth - 1, longs, 0, kth - 1)
        elif s < kth <= l:
            if longs[kth - s - 1] >= shorts[s - 1]:
                return longs[kth - s - 1]
            return self.getMedium(shorts, 0, s - 1, longs, kth - s, kth - 1)
        else:
            if shorts[kth - l - 1] >= longs[l - 1]:
                return shorts[kth - l - 1]
            if longs[kth - s - 1] >= shorts[s - 1]:
                return longs[kth - s - 1]
            return self.getMedium(shorts, kth - l, s - 1, longs, kth - s, l - 1)


    def getMedium(self, nums1, s1, e1, nums2, s2, e2):
        while s1 < e1:
            mid1 = (s1 + e1) // 2
            mid2 = (s2 + e2) // 2
            # 1 2 3 4 5
            # 1 2 3 4 5
            if nums1[mid1] == nums2[mid2]:
                return nums1[mid1]
            elif (e1 - s1 + 1) % 2 == 1:
                if nums1[mid1] > nums2[mid2]:
                    if nums2[mid2] >= nums1[mid1 - 1]:
                        return nums2[mid2]
                    e1 = mid1 - 1
                    s2 = mid2 + 1
                else:
                    if nums1[mid1] >= nums2[mid2 - 1]:
                        return nums1[mid1]
                    e2 = mid2 - 1
                    s1 = mid1 + 1
            else:
                if nums1[mid1] > nums2[mid2]:
                    e1 = mid1
                    s2 = mid2 + 1
                else:
                    e2 = mid2
                    s1 = mid1 + 1
        return min(nums1[s1], nums2[s2])
```
##### 最长回文子串
```
    def longestPalindrome(self, s: str) -> str:
        res = ""
        for i in range(len(s)):
            # 以 s[i] 为中心的最长回文子串
            s1 = self.palindrome(s, i, i)
            # 以 s[i] 和 s[i+1] 为中心的最长回文子串
            s2 = self.palindrome(s, i, i + 1)
            # res = longest(res, s1, s2)
            res = res if len(res) > len(s1) else s1
            res = res if len(res) > len(s2) else s2
        return res

    def palindrome(self, s: str, l: int, r: int) -> str:
        # 防止索引越界
        while l >= 0 and r < len(s) and s[l] == s[r]:
            # 向两边展开
            l -= 1
            r += 1
        # 返回以 s[l] 和 s[r] 为中心的最长回文串
        return s[l+1:r]
```
##### 正则表达式
```
    def isMatch(self, s: str, p: str) -> bool:
        @cache
        def dp(s, p, i, j):
            if i == -1 and j == -1:
                return True
            if i == -1:
                if (j + 1) % 2 == 1:
                    return False
                for idx, c in enumerate(p[:j + 1]):
                    if idx % 2 == 1 and c != "*":
                        return False
                return True
            if j == -1:
                return False
            
            if s[i] == p[j]:
                return dp(s, p, i - 1, j - 1)
            else:
                if p[j] == ".":
                    return dp(s, p, i - 1, j - 1)
                elif p[j] == "*":
                    if p[j - 1] == s[i] or p[j - 1] == ".":
                        return dp(s, p, i - 1, j) or dp(s, p, i, j - 2)
                    else:
                        return dp(s, p, i, j - 2)
                else:
                    return False
        return dp(s, p, len(s) - 1, len(p) - 1)
```
##### 盛水最多的容器
```
    def maxArea(self, height: List[int]) -> int:
        l, r = 0, len(height) - 1
        res = 0
        while l <= r:
            res = max(res, (r - l) * min(height[l], height[r]))
            if height[l] <= height[r]:
                l += 1
            else:
                r -= 1
        return res
```
##### 三数之和
```
    def threeSum(self, nums: List[int]) -> List[List[int]]:

        def twoSum(nums, i, j, target):
            res = []
            while i < j:
                if nums[i] + nums[j] == target:
                    res.append([nums[i], nums[j]])
                    while i < j and nums[i + 1] == nums[i]:
                        i += 1
                    i += 1
                    while i < j and nums[j - 1] == nums[j]:
                        j -= 1
                    j -= 1
                elif nums[i] + nums[j] > target:
                    j -= 1
                else:
                    i += 1
            return res
        nums.sort()
        res = []
        idx = 0
        while idx < len(nums) - 2:
            cur = twoSum(nums, idx + 1, len(nums) - 1, -nums[idx])
            if len(cur) != 0:
                for pair in cur:
                    pair.append(nums[idx])
                    res.append(pair)
                while idx + 1 < len(nums) - 2 and nums[idx + 1] == nums[idx]:
                    idx += 1
            idx += 1
        return res
```
##### 电话号码的字母组合
```
    def letterCombinations(self, digits: str) -> List[str]:
        mapping = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]
        res = []

        if digits == "":
            return res
        def backtrack(digits, i, path):
            if i == len(digits):
                res.append("".join(path))
                return
            for c in mapping[int(digits[i])]:
                path.append(c)
                backtrack(digits, i + 1, path)
                path.pop()
        
        backtrack(digits, 0, [])
        return res
```
##### 删除链表的倒数第 N 个结点
```
    def removeNthFromEnd(self, head, n):
        dummy = ListNode(0, next = head)
        p1 = dummy
        for i in range(n + 1):
            p1 = p1.next
        p2 = dummy
        while p1 != None:
            p1 = p1.next
            p2 = p2.next
        p2.next = p2.next.next
        return dummy.next
```
##### 有效的括号
```
    def isValid(self, s: str) -> bool:
        stack = []
        for i in s:
            if i in ["(", "[", "{"]:
                stack.append(i)
            else:
                pos = stack.pop() if len(stack) > 0 else ""
                if i == ")":
                    if pos != "(":
                        return False
                elif i == "]":
                    if pos != "[":
                        return False
                else:
                    if pos != "{":
                        return False
        return True if len(stack) == 0 else False
```
##### 合并两个有序链表
```
    def mergeTwoLists(self, list1, list2):
        p1 = list1
        p2 = list2
        dummy = ListNode(0)
        cur = dummy
        while p1 != None and p2 != None:
            if p1.val <= p2.val:
                cur.next = p1
                p1 = p1.next
            else:
                cur.next = p2
                p2 = p2.next
            cur = cur.next
        if p1 != None:
            cur.next = p1
        if p2 != None:
            cur.next = p2
        return dummy.next
```
##### 括号生成
```
    def generateParenthesis(self, n: int) -> List[str]:
        res = []

        def backtrack(left, right, path):
            if right < left:
                return
            if left == 0 and right == 0:
                res.append("".join(path[:]))
            if left < 0 or right < 0:
                return
            path.append("(")
            backtrack(left - 1, right, path)
            path.pop()
            path.append(")")
            backtrack(left, right - 1, path)
            path.pop()
        
        backtrack(n, n, [])
        return res
```
##### 合并 K 个升序链表
```
from queue import PriorityQueue
class Solution:
    def mergeKLists(self, lists):
        pq = PriorityQueue()
        for root in lists:
            if root != None:
                pq.put(Node(root, root.val))
        res = ListNode(0)
        tmp = res
        while len(pq.queue) != 0:
            cur = pq.get().ListNode
            tmp.next = cur
            tmp = tmp.next
            if cur.next != None:
                pq.put(Node(cur.next, cur.next.val))
        return res.next
            
class Node:
    def __init__(self, ListNode, val):
        self.ListNode = ListNode
        self.val = val

    def __lt__(self, other):
        return self.val <= other.val
```
##### 下一个排列
```
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        def reverse(i, j):
            while i < j:
                nums[i], nums[j] = nums[j], nums[i]
                i += 1
                j -= 1
        
        i = len(nums) - 1
        while i - 1 >= 0 and nums[i - 1] >= nums[i]:
            i -= 1
        if i == 0:
            reverse(i, len(nums) - 1)
        else:
            j = i
            i -= 1
            k = len(nums) - 1
            while k >= 0 and nums[i] >= nums[k]:
                k -= 1
            nums[i], nums[k] = nums[k], nums[i]
            reverse(j, len(nums) - 1)
```
##### 最长有效括号
```
    def longestValidParentheses(self, s: str) -> int:
        
        @cache
        def dp(i):
            if i == -1:
                return 0
            if s[i] == "(":
                return 0
            if i - 1 >= 0 and s[i - 1] == "(":
                return dp(i - 2) + 2
            else:
                if i - dp(i - 1) - 1 >= 0 and s[i - dp(i - 1) - 1] == "(":
                    return dp(i - 1) + 2 + dp(i - dp(i - 1) - 2)
                else:
                    return 0
        res = 0
        for i in range(len(s)):
            res = max(res, dp(i))
        return res
```
##### 搜索旋转排序数组
```
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        # 因为是闭区间，所以结束条件为 left > right
        while left <= right:
            mid = (right + left) // 2
            if nums[mid] == target:
                return mid
            if nums[mid] >= nums[left]:
                if target >= nums[left]:
                    if nums[mid] < target:
                        left = mid + 1
                    else:
                        right = mid - 1
                else:
                    left = mid + 1
            else:
                if target < nums[left]:
                    if nums[mid] < target:
                        left = mid + 1
                    else:
                        right = mid - 1
                else:
                    right = mid - 1
        return -1
```
##### 在排序数组中查找元素的第一个和最后一个位置
```
    def searchRange(self, nums: List[int], target: int) -> List[int]:

        def findLeft(nums, target):
            left, right = 0, len(nums) - 1
            while left <= right:
                mid = (right + left) // 2
                if nums[mid] == target:
                    right = mid - 1
                elif nums[mid] < target:
                    left = mid + 1
                else:
                    right = mid - 1
            if left >= len(nums):
                return -1
            return left if nums[left] == target else -1


        def findRight(nums, target):
            left, right = 0, len(nums) - 1
            while left <= right:
                mid = (right + left) // 2
                if nums[mid] == target:
                    left = mid + 1
                elif nums[mid] < target:
                    left = mid + 1
                else:
                    right = mid - 1
            if right < 0:
                return -1
            return right if nums[right] == target else -1
        
        return [findLeft(nums, target), findRight(nums, target)]
```
##### 组合总和
无重复元素 同一个数字可以无限制重复被选取
```
    def combinationSum(self, candidates, target):
        res = []
        def backtrack(i, rest, path):
            if rest == 0:
                res.append(path[:])
                return
            if rest < 0:
                return
            if i == len(candidates):
                return
            for j in range(i, len(candidates)):
                path.append(candidates[j])
                backtrack(j, rest - candidates[j], path)
                path.pop()
        backtrack(0, target, [])
        return res
```
##### 接雨水
```
    def trap(self, height: List[int]) -> int:
        stack = []
        res = 0
        for i in range(len(height)):
            while len(stack) != 0 and height[stack[-1]] <= height[i]:
                cur = stack.pop()
                if height[cur] < height[i]:
                    leftIdx = stack[-1] if len(stack) != 0 else -1
                    if leftIdx == -1:
                        continue
                    res += (min(height[leftIdx], height[i]) - height[cur]) * (i - leftIdx - 1)
            stack.append(i)
        return res

    def trap(self, height: List[int]) -> int:
        ans = left = pre_max = suf_max = 0
        right = len(height) - 1
        while left < right:
            pre_max = max(pre_max, height[left])
            suf_max = max(suf_max, height[right])
            if pre_max < suf_max:
                ans += pre_max - height[left]
                left += 1
            else:
                ans += suf_max - height[right]
                right -= 1
        return ans
```
##### 全排列
```
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        used = [False] * len(nums)

        def backtrack(path):
            if len(path) == len(nums):
                res.append(path[:])
                return
            for i in range(len(nums)):
                if used[i]:
                    continue
                used[i] = True
                path.append(nums[i])
                backtrack(path)
                path.pop()
                used[i] = False
        backtrack([])
        return res
```
##### 旋转图像
```
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        def rotate(i, l):
            for _ in range(l):
                tmp = matrix[i][i + _]
                matrix[i][i + _] = matrix[i + l - _][i]
                matrix[i + l - _][i] = matrix[i + l][i + l - _]
                matrix[i + l][i + l - _] = matrix[i + _][i + l]
                matrix[i + _][i + l] = tmp
        
        l, r = 0, len(matrix) - 1
        while l < r:
            rotate(l, r - l)
            l += 1
            r -= 1
```
##### 字母异位词分组
```
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        codeToGroup = {}
        for s in strs:
            # 对字符串进行编码
            code = self.encode(s)
            # 把编码相同的字符串放在一起
            if code not in codeToGroup:
                codeToGroup[code] = []
            codeToGroup[code].append(s)

        # 获取结果
        res = []
        for group in codeToGroup.values():
            res.append(group)

        return res

    # 利用每个字符的出现次数进行编码
    def encode(self, s: str) -> str:
        count = [0] * 26
        for c in s:
            delta = ord(c) - ord('a')
            count[delta] += 1
        return str(count)
```
##### 最大子数组和
```
    def maxSubArray(self, nums: List[int]) -> int:
        dp = [0] * len(nums)
        dp[0] = nums[0]
        for i in range(1, len(nums)):
            if dp[i - 1] >= 0:
                dp[i] = dp[i - 1] + nums[i]
            else:
                dp[i] = nums[i]
        return max(dp)
```
##### 跳跃游戏
```
    def canJump(self, nums: List[int]) -> bool:
        far = 0
        for i in range(len(nums) - 1):
            far = max(far, i + nums[i])
            if far <= i:
                return False
        return far >= len(nums) - 1
```
#####  合并区间
```
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        res = []
        intervals.sort(key=lambda a: a[0])
        res.append(intervals[0])
        for cur in intervals[1:]:
            last = res[-1]
            if cur[0] <= last[1]:
                last[1] = max(last[1], cur[1])
            else:
                res.append(cur)
        return res
```
##### 不同路径
```
    def uniquePaths(self, m: int, n: int) -> int:
        
        @cache
        def fac(x):
            if x <= 1:
                return 1
            return x * fac(x - 1)
        
        return fac(n + m - 2) // fac(m - 1) // fac(n - 1)
```
##### 最小路径和
```
    def minPathSum(self, grid: List[List[int]]) -> int:

        @cache
        def dp(i, j):
            if i == len(grid) - 1 and j == len(grid[0]) - 1:
                return grid[i][j]
            if i == len(grid) or j == len(grid[0]):
                return float("inf")
            p1 = float("inf")
            p2 = float("inf")
            if dp(i + 1,j) != float("inf"):
                p1 = dp(i + 1,j) + grid[i][j]
            if dp(i,j + 1) != float("inf"):
                p2 = dp(i,j + 1) + grid[i][j]
            return min(p1, p2)
        
        return dp(0, 0)
```
##### 爬楼梯
```
    def climbStairs(self, n: int) -> int:

        @cache
        def f(x):
            if x == 1:
                return 1
            if x == 2:
                return 2
            return f(x - 1) + f(x - 2)
        
        return f(n)
```
##### 编辑距离
```
    def minDistance(self, word1: str, word2: str) -> int:
        
        @cache
        def dp(i, j):
            if i < 0 and j < 0:
                return 0
            if i < 0:
                return j + 1
            if j < 0:
                return i + 1
            if word1[i] == word2[j]:
                return dp(i - 1, j - 1)
            return min(dp(i - 1, j), dp(i, j - 1), dp(i - 1, j - 1)) + 1
        
        return dp(len(word1) - 1, len(word2) - 1)
```
##### 颜色分类
```
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        
        def quicksort(L, R):
            if L >= R:
                return
            l, r = partition(L, R)
            quicksort(L, l - 1)
            quicksort(r + 1, R)
        
        def partition(L, R):
            less = L - 1
            more = R
            idx = L
            while idx < more:
                if nums[idx] == nums[R]:
                    idx += 1
                elif nums[idx] < nums[R]:
                    nums[less + 1], nums[idx] = nums[idx], nums[less + 1]
                    idx += 1
                    less += 1
                else:
                    nums[idx], nums[more - 1] = nums[more - 1], nums[idx]
                    more -= 1
            nums[more], nums[R] = nums[R], nums[more]
            return less + 1, more
        
        quicksort(0, len(nums) - 1)
```
##### 最小覆盖子串
```
    def minWindow(self, s: str, t: str) -> str:
        window, need = defaultdict(int), defaultdict(int)
        for c in t:
            need[c] += 1
        l, r, valid = 0, 0, 0
        start = 0
        res = float("inf")
        while r < len(s):
            c = s[r]
            r += 1
            if c in need:
                window[c] += 1
                if window[c] == need[c]:
                    valid += 1
            while valid == len(need):
                cur = r - l
                if cur < res:
                    res = cur
                    start = l
                d = s[l]
                l += 1
                if d in need:
                    if window[d] == need[d]:
                        valid -= 1
                    window[d] -= 1
        return s[start:start+res] if res != float("inf") else ""
```
##### 子集
```
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []

        def backtrack(i, path):
            if i == len(nums):
                res.append(path[:])
                return
            path.append(nums[i])
            backtrack(i + 1, path)
            path.pop()
            backtrack(i + 1, path)
        
        backtrack(0, [])
        return res
```
##### 单词搜索
```
    def exist(self, board, word) -> bool:
        visited = [[False for _ in range(len(board[0]))] for _ in range(len(board))]
        def dfs(i, j, k):
            if k == len(word):
                return True
            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:
                return False
            if visited[i][j] == True:
                return False
            visited[i][j] = True
            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
            visited[i][j] = False
            return res
        
        res = False
        for i in range(len(board)):
            for j in range(len(board[0])):
                cur = dfs(i, j, 0)
                if cur == True:
                    return True
        return res
```
##### 柱状图中最大的矩形
```
    def largestRectangleArea(self, heights: List[int]) -> int:
        res = 0
        stack = []
        for i in range(len(heights)):
            while len(stack) != 0 and heights[stack[-1]] > heights[i]:
                cur = stack.pop()
                leftIdx = stack[-1] if len(stack) != 0 else -1
                area = (i - leftIdx - 1) * heights[cur]
                res = max(res, area)
            stack.append(i)
        while len(stack) != 0:
            cur = stack.pop()
            leftIdx = stack[-1] if len(stack) != 0 else -1
            rightIdx = len(heights)
            area = (rightIdx - leftIdx - 1) * heights[cur]
            res = max(res, area)
        return res
```
##### 最大矩形
```
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        n = len(matrix)
        heights = [0] * len(matrix[0])
        res = 0
        for i in range(n):
            for j in range(len(matrix[0])):
                heights[j] = heights[j] + 1 if matrix[i][j] == "1" else 0
            res = max(res, self.largestRectangleArea(heights))
        return res


    def largestRectangleArea(self, heights: List[int]) -> int:
        res = 0
        stack = []
        for i in range(len(heights)):
            while len(stack) != 0 and heights[stack[-1]] > heights[i]:
                cur = stack.pop()
                leftIdx = stack[-1] if len(stack) != 0 else -1
                area = (i - leftIdx - 1) * heights[cur]
                res = max(res, area)
            stack.append(i)
        while len(stack) != 0:
            cur = stack.pop()
            leftIdx = stack[-1] if len(stack) != 0 else -1
            rightIdx = len(heights)
            area = (rightIdx - leftIdx - 1) * heights[cur]
            res = max(res, area)
        return res
```
##### 二叉树的中序遍历
```
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        def traverse(root):
            if root == None:
                return
            traverse(root.left)
            res.append(root.val)
            traverse(root.right)
        
        traverse(root)
        return res
```
##### 不同的二叉搜索树
卡特兰数
```
    def numTrees(self, n: int) -> int:

        @cache
        def fac(n):
            if n == 0:
                return 1
            return n * fac(n - 1)
        
        return fac(2 * n) // fac(n) // fac(n) - fac(2 * n) // fac(n - 1) // fac(n + 1)
```
##### 验证二叉搜索树
```
    def isValidBST(self, root: TreeNode) -> bool:
        self.pre = -float("inf")

        def traverse(root):
            if root == None:
                return True
            
            if traverse(root.left) == False:
                return False
            if root.val <= self.pre:
                return False
            self.pre = root.val
            return traverse(root.right)
            
        
        return traverse(root)
```
##### 对称二叉树
```
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:

        def same(p, q):
            if p == None and q == None:
                return True
            if p == None or q == None:
                return False
            return p.val == q.val and same(p.left, q.right) and same(p.right, q.left)
        
        return same(root.left, root.right)
```
##### 二叉树的层序遍历
```
from collections import deque
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root == None:
            return []
        container = deque()
        container.append(root)
        res = []
        while len(container) != 0:
            size = len(container)
            cur = []
            for i in range(size):
                item = container.popleft()
                cur.append(item.val)
                if item.left != None:
                    container.append(item.left)
                if item.right != None:
                    container.append(item.right)
            res.append(cur)
        return res
```
##### 二叉树的最大深度
```
    def maxDepth(self, root: Optional[TreeNode]) -> int:

        if not root:
            return 0
        leftMax = self.maxDepth(root.left)
        rightMax = self.maxDepth(root.right)
        # 根据左右子树的最大深度推出原二叉树的最大深度
        return 1 + max(leftMax, rightMax)
```
##### 从前序与中序遍历序列构造二叉树
```
    def buildTree(self, preorder, inorder):

        def build(pl, pr, il, ir):
            if pl > pr:
                return None
            rootVal = preorder[pl]
            root = TreeNode(rootVal)
            idx = il
            while idx <= ir and inorder[idx] != rootVal:
                idx += 1
            root.left = build(pl + 1, pl + idx - il, il, idx - 1)
            root.right = build(pl + idx - il + 1, pr, idx + 1, ir)
            return root
        
        return build(0, len(preorder) - 1, 0, len(inorder) - 1)
```
##### 二叉树展开为链表
```
    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if root == None:
            return
        self.flatten(root.left)
        self.flatten(root.right)

        left = root.left
        right = root.right

        root.left = None
        root.right = left

        p = root
        while p.right != None:
            p = p.right
        p.right = right
```
##### 买卖股票的最佳时机
```
    def maxProfit(self, prices: List[int]) -> int:

        @cache
        def dp(i, rest, hold):
            if i == len(prices):
                return 0
            if rest == 1:
                return max(dp(i + 1, rest, hold), dp(i + 1, rest - 1, hold ^ True) - prices[i])
            else:
                if hold:
                    return max(dp(i + 1, rest, hold ^ True) + prices[i], dp(i + 1, rest, hold))
                else:
                    return dp(i + 1, rest, hold)
        
        return dp(0, 1, False)
```
##### 二叉树中的最大路径和
```
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        
        def dfs(root):
            if root == None:
                return 0
            left = dfs(root.left)
            right = dfs(root.right)
            rootmax = root.val + max(left, 0) + max(right, 0)
            self.res = max(self.res, rootmax)
            return root.val + max(left, right, 0)
        self.res = float("-inf")
        dfs(root)
        return self.res
```
##### 最长连续序列
```
    def longestConsecutive(self, nums: List[int]) -> int:
        set_num = set(nums)
        res = 0
        for num in set_num:
            if num - 1 in set_num:
                continue
            cur = num
            cur_len = 1
            while cur + 1 in set_num:
                cur += 1
                cur_len += 1
            res = max(res, cur_len)
        return res
```
##### 只出现一次的数字
```
    def singleNumber(self, nums: List[int]) -> int:
        res = 0
        for i in nums:
            res ^= i
        return res
```
##### 单词拆分
```
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:

        @cache
        def dp(i):
            if i == len(s):
                return True
            res = False
            for word in wordDict:
                size = len(word)
                if word == s[i: i + size]:
                    cur = dp(i + size)
                    if cur:
                        return True
            return res
        
        return dp(0)
```
##### 环形链表
```
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        fast = slow = head
        while fast != None and fast.next != None:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                return True
        return False
```
##### 环形链表 II
```
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        fast = slow = head
        while fast != None and fast.next != None:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                break
        if fast == None or fast.next == None:
            return None
        fast = head
        while fast != slow:
            fast = fast.next
            slow = slow.next
        return slow
```
##### LRU 缓存
```
class LRUCache:

    def __init__(self, capacity: int):
        self.dl = DoubleList()
        self.capacity = capacity
        self.key2Node = {}


    def get(self, key: int) -> int:
        if key not in self.key2Node:
            return -1
        cur = self.key2Node[key]
        self.dl.move2End(cur)
        return cur.value

    def put(self, key: int, value: int) -> None:
        if key in self.key2Node:
            cur = self.key2Node[key]
            cur.value = value
            self.dl.move2End(cur)
        else:
            if self.capacity == len(self.key2Node):
                remove = self.dl.removeHead()
                self.key2Node.pop(remove.key)
            cur = Node(key, value)
            self.key2Node[key] = cur
            self.dl.add(cur)

class Node:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.pre = None
        self.next = None
    
class DoubleList:
    def __init__(self):
        self.head = None
        self.tail = None
    
    def add(self, node):
        if self.head == None:
            self.head = node
            self.tail = node
        else:
            self.tail.next = node
            node.pre = self.tail
            self.tail = node
    
    def move2End(self, node):
        if self.tail == node:
            return
        elif self.head == node:
            self.head = self.head.next
            self.head.pre = None
        else:
            node.pre.next = node.next
            node.next.pre = node.pre
        node.next = None
        node.pre = self.tail
        self.tail.next = node
        self.tail = node
    
    def removeHead(self):
        if self.head == None:
            return None
        res = self.head
        if self.head == self.tail:
            self.head = None
            self.tail = None
        else:
            self.head = self.head.next
            self.head.pre = None
            res.next = None
        return res
```
##### LFU
```
class LFUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.key2node = {}
        self.node2list = {}
        self.size = 0
        self.headList = None

    def adjustNodeFromList(self, curList, curNode):
        curList.deleteNode(curNode)
        if curList.next != None and curList.next.head.times == curNode.times:
            newList = curList.next
            newList.addNode(curNode)
        else:
            if curList.next == None:
                newList = NodeList()
                newList.addNode(curNode)
                newList.pre = curList
                curList.next = newList
            else:
                newList = NodeList()
                newList.addNode(curNode)
                newList.pre = curList
                newList.next = curList.next
                curList.next = newList
                newList.next.pre = newList
        self.node2list[curNode] = newList
    def adjustList(self, curList):
        if curList.isEmpty():
            if curList == self.headList and curList.next != None:
                self.headList = self.headList.next
                curList.next = None
                self.headList.pre = None
            elif curList != self.headList and curList.next == None:
                curList.pre.next = None
                curList.pre = None
            elif curList != self.headList and curList.next != None:
                curList.pre.next = curList.next
                curList.next.pre = curList.pre
                curList.next = None
                curList.pre = None
            else:
                self.headList = None

    def get(self, key: int) -> int:
        if key not in self.key2node:
            return -1
        curNode = self.key2node[key]
        curList = self.node2list[curNode]
        curNode.times += 1
        self.adjustNodeFromList(curList, curNode)
        self.adjustList(curList)
        print(1)
        return curNode.value

    def put(self, key: int, value: int) -> None:
        if key in self.key2node:
            curNode = self.key2node[key]
            curList = self.node2list[curNode]
            curNode.times += 1
            curNode.value = value
            self.adjustNodeFromList(curList, curNode)
            self.adjustList(curList)
        else:
            if self.size == self.capacity:
                pop = self.headList.popHead()
                self.adjustList(self.headList)
                self.key2node.pop(pop.key)
                self.size -= 1
            newNode = Node(key, value, 1)
            if self.headList == None:
                self.headList = NodeList()
                self.headList.addNode(newNode)
            else:
                if self.headList.head.times == 1:
                    self.headList.addNode(newNode)
                else:
                    newList = NodeList()
                    self.headList.pre = newList
                    newList.next = self.headList
                    self.headList = newList
                    self.headList.addNode(newNode)
            self.key2node[key] = newNode
            self.node2list[newNode] = self.headList
            self.size += 1
        print(2)


class Node:
    def __init__(self, key, value, times):
        self.key = key
        self.value = value
        self.times = times
        self.up = None
        self.down = None

class NodeList:
    def __init__(self):
        self.head = None
        self.tail = None
        self.pre = None
        self.next = None

    def addNode(self, node):
        if self.head == None:
            self.tail = node
            self.head = node
        else:
            self.tail.down = node
            node.up = self.tail
            self.tail = node

    def isEmpty(self):
        return self.head == None

    def deleteNode(self, node):
        if self.head == self.tail:
            self.head = None
            self.tail = None
        else:
            if node == self.head:
                self.head = self.head.down
                self.head.up = None
            elif node == self.tail:
                self.tail = self.tail.up
                self.tail.down = None
            else:
                node.up.down = node.down
                node.down.up = node.up
        node.up = None
        node.down = None

    def popHead(self):
        res = self.head
        if self.head == self.tail:
            self.head = None
            self.tail = None
        else:
            self.head = self.head.down
            self.head.up = None
            res.down = None
        return res
```
##### 排序链表
```
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head

        # Split list
        prev, slow, fast = None, head, head
        while fast and fast.next:
            prev, slow, fast = slow, slow.next, fast.next.next
        prev.next = None

        # Sort each half
        l1 = self.sortList(head)
        l2 = self.sortList(slow)

        # Merge sorted halves
        return self.mergeTwoLists(l1, l2)

    def mergeTwoLists(self, l1, l2):
        dummy = ListNode(0)
        tail = dummy
        while l1 and l2:
            if l1.val < l2.val:
                tail.next, l1 = l1, l1.next
            else:
                tail.next, l2 = l2, l2.next
            tail = tail.next
        tail.next = l1 or l2
        return dummy.next
```
##### 乘积最大子数组
```
    def maxProduct(self, nums: List[int]) -> int:

        dp = [[0, 0] for _ in range(len(nums))]
        dp[0][0] = dp[0][1] = nums[0]
        for i in range(1, len(nums)):
            if nums[i] > 0:
                dp[i][0] = max(dp[i - 1][0] * nums[i], nums[i])
                dp[i][1] = min(dp[i - 1][1] * nums[i], nums[i])
            elif nums[i] == 0:
                continue
            else:
                dp[i][0] = max(dp[i - 1][1] * nums[i], nums[i])
                dp[i][1] = min(dp[i - 1][0] * nums[i], nums[i])
        return max([i[0] for i in dp])
```
##### 最小栈
```
class MinStack:

    def __init__(self):
        self.stack = []
        self.min = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if len(self.min) == 0:
            self.min.append(val)
        else:
            self.min.append(min(val, self.min[-1]))

    def pop(self) -> None:
        self.stack.pop()
        self.min.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min[-1]
```
##### 相交链表
```
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        size1 = size2 = 0
        cur = headA
        while cur != None:
            cur = cur.next
            size1 += 1
        cur = headB
        while cur != None:
            cur = cur.next
            size2 += 1
        diff = abs(size1 - size2)
        longL = headA if size1 >= size2 else headB
        shortL = headB if longL == headA else headA
        for i in range(diff):
            longL = longL.next
        while longL != None and longL != shortL:
            longL = longL.next
            shortL = shortL.next
        return longL   
```
##### 多数元素
```
    def majorityElement(self, nums: List[int]) -> int:
        cand = HP = 0
        for i in nums:
            if HP == 0:
                HP += 1
                cand = i
            elif i == cand:
                HP += 1
            else:
                HP -= 1
        return cand
```
##### 打家劫舍
```
    def rob(self, nums: List[int]) -> int:

        @cache
        def dp(i):
            if i >= len(nums):
                return 0
            return max(dp(i + 1), nums[i] + dp(i + 2))
        
        return dp(0)
```
##### 岛屿数量
```
    def numIslands(self, grid: List[List[str]]) -> int:

        def dfs(i, j):
            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == "0":
                return
            grid[i][j] = "0"
            dfs(i + 1, j)
            dfs(i - 1, j)
            dfs(i, j + 1)
            dfs(i, j - 1)
            
        res = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == "1":
                    dfs(i, j)
                    res += 1
        return res
```
##### 反转链表
```
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre, cur, nxt = None, head, head
        while cur != None:
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        return pre
```
##### K 个一组翻转链表
```
    def reverseKGroup(self, head, k): 
        def reverse(a, b):
            pre, cur, nxt = None, a, a
            while cur != b:
                nxt = cur.next
                cur.next = pre
                pre = cur
                cur = nxt
            return pre
        
        if head == None:
            return None
        a = b = head
        for i in range(k):
            if b == None:
                return head
            b = b.next
        new_head = reverse(a, b)
        a.next = self.reverseKGroup(b, k)
        return new_head


    def reverseKGroup(self, head, k) -> Optional[ListNode]: 
        def reverse(root, size):
            pre, cur, nxt = None, root, root
            count = 0
            while cur != None:
                cur = cur.next
                count += 1
                if count == size:
                    break
            if count == size:
                cur = root
                for i in range(size):
                    nxt = cur.next
                    cur.next = pre
                    pre = cur
                    cur = nxt
                root.next = cur
                return pre
            else:
                return root
        dummy = ListNode(-1)
        dummy.next = head
        cur = head
        pre = dummy
        while cur != None:
            new_head = reverse(cur, k)
            if cur == new_head:
                break
            pre.next = new_head
            pre = cur
            cur = cur.next
        return dummy.next
```
##### 课程表
```
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        indegree = {i: 0 for i in range(numCourses)} 
        zero = []
        graph = [[] for _ in range(numCourses)]
        for prerequisite in prerequisites:
            post, pre = prerequisite
            graph[pre].append(post)
            indegree[post] += 1
        for key in indegree:
            if indegree[key] == 0:
                zero.append(key)
        finish = 0
        while len(zero) != 0:
            cur = zero.pop()
            finish += 1
            for nxt in graph[cur]:
                indegree[nxt] -= 1
                if indegree[nxt] == 0:
                    zero.append(nxt)
        return True if finish == numCourses else False
```
##### 实现 Trie (前缀树)
```
class Trie:

    def __init__(self):
        self.root = Node(0)

    def insert(self, word: str) -> None:
        cur = self.root
        for c in word:
            if cur.children[ord(c) - ord("a")] == None:
                cur.children[ord(c) - ord("a")] = Node(c)
            cur = cur.children[ord(c) - ord("a")]
        cur.finish = True

    def search(self, word: str) -> bool:
        cur = self.root
        for c in word:
            if cur.children[ord(c) - ord("a")] == None:
                return False
            cur = cur.children[ord(c) - ord("a")]
        return True if cur.finish == True else False

    def startsWith(self, prefix: str) -> bool:
        cur = self.root
        for c in prefix:
            if cur.children[ord(c) - ord("a")] == None:
                return False
            cur = cur.children[ord(c) - ord("a")]
        return True

class Node:
    def __init__(self, val):
        self.val = val
        self.finish = False
        self.children = [None]*26
```
##### 数组中的第K个最大元素
```
    def findKthLargest(self, nums: List[int], k: int) -> int:

        def search(L, R, k):
            if L >= R:
                return nums[L]
            rdm = L + int((R - L + 1) * random.random())
            nums[rdm], nums[R] = nums[R], nums[rdm]
            l, r = partition(L, R)
            if l <= k <= r:
                return nums[k]
            elif k < l:
                return search(L, l - 1, k)
            else:
                return search(r + 1, R, k)
        
        def partition(L, R):
            less, more = L - 1, R
            idx = L
            while idx < more:
                if nums[idx] == nums[R]:
                    idx += 1
                elif nums[idx] < nums[R]:
                    nums[idx], nums[less + 1] = nums[less + 1], nums[idx]
                    idx += 1
                    less += 1
                else:
                    nums[idx], nums[more - 1] = nums[more - 1], nums[idx]
                    more -= 1
            nums[R], nums[more] = nums[more], nums[R]
            return less + 1, more
        
        return search(0, len(nums) - 1, len(nums) - k)
```
##### 最大正方形
```
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        n = len(matrix)
        heights = [0] * len(matrix[0])
        res = 0
        for i in range(n):
            for j in range(len(matrix[0])):
                heights[j] = heights[j] + 1 if matrix[i][j] == "1" else 0
            res = max(res, self.largestRectangleArea(heights))
        return res * res

    def largestRectangleArea(self, heights: List[int]) -> int:
        res = 0
        stack = []
        for i in range(len(heights)):
            while len(stack) != 0 and heights[stack[-1]] > heights[i]:
                cur = stack.pop()
                leftIdx = stack[-1] if len(stack) != 0 else -1
                size = i - leftIdx - 1
                if size >= heights[cur]:
                    res = max(res, heights[cur])
            stack.append(i)
        while len(stack) != 0:
            cur = stack.pop()
            leftIdx = stack[-1] if len(stack) != 0 else -1
            rightIdx = len(heights)
            size = rightIdx - leftIdx - 1
            if size >= heights[cur]:
                res = max(res, heights[cur])
        return res


    def maximalSquare(self, matrix: List[List[str]]) -> int:

        @cache
        def dp(i, j):
            if i == 0 or j == 0:
                return 1 if matrix[i][j] == "1" else 0
            if matrix[i][j] == "0":
                return 0
            return min(dp(i - 1, j), dp(i, j - 1), dp(i - 1, j - 1)) + 1
        res = 0
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                res = max(res, dp(i, j))
        return res * res
```
##### 翻转二叉树
```
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:

        def traverse(root):
            if root == None:
                return
            left = traverse(root.left)
            right = traverse(root.right)
            root.left = right
            root.right = left
            return root
        
        return traverse(root)
```
##### 回文链表
```
    def isPalindrome(self, head: Optional[ListNode]) -> bool:
        if head.next == None:
            return True

        def reverse(root):
            pre, cur, nxt = None, root, root
            while cur != None:
                nxt = cur.next
                cur.next = pre
                pre = cur
                cur = nxt
            return pre
        
        n = 0
        cur = head
        while cur != None:
            cur = cur.next
            n += 1
        cur = head
        for i in range(n // 2):
            cur = cur.next
        new_root = reverse(cur)
        while head != new_root and new_root != None:
            if head.val != new_root.val:
                return False
            head = head.next
            new_root = new_root.next
        return True
```
##### 二叉树的最近公共祖先
```
    def lowestCommonAncestor(self, root, p, q):

        def dfs(root, p, q):
            if root == None:
                return None
            if root == p or root == q:
                return root
            left = dfs(root.left, p, q)
            right = dfs(root.right, p, q)
            if left != None and right != None:
                return root
            return left if left != None else right
        
        return dfs(root, p, q)
```
##### 除自身以外数组的乘积
```
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        ans, tmp = [1] * len(nums), 1
        ## 下三角
        for i in range(1, len(nums)):
            ans[i] = ans[i - 1] * nums[i - 1]
        for i in range(len(nums) - 2, -1, -1):
	        ## 上三角
            tmp *= nums[i + 1]
            ans[i] *= tmp
        return ans
```
##### 滑动窗口最大值
```
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        qmax = deque()
        res = [0] * (len(nums) - k + 1)
        idx = 0
        for R in range(len(nums)):
            while len(qmax) != 0 and nums[qmax[-1]] <= nums[R]:
                qmax.pop()
            qmax.append(R)
            if qmax[0] == R - k:
                qmax.popleft()
            if R >= k - 1:
                res[idx] = nums[qmax[0]]
                idx += 1
        return res
```
##### 搜索二维矩阵 II
```
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        row, col = 0, len(matrix[0]) - 1
        while row < len(matrix) and col >= 0:
            if matrix[row][col] == target:
                return True
            elif matrix[row][col] > target:
                col -= 1
            else:
                row += 1
        return False
```
##### 完全平方数
```
    def numSquares(self, n: int) -> int:

        @cache
        def dp(i):
            if i <= 0:
                return 0
            if i == 1:
                return 1
            res = float("inf")
            j = 1
            while j * j <= i:
                res = min(res, dp(i - j * j) + 1)
                j += 1
            return res

        return dp(n)
```
##### 移动零
```
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        left = right = 0
        while right < len(nums):
            if nums[right] != 0:
                nums[left] = nums[right]
                left += 1
            right += 1
        while left < len(nums):
            nums[left] = 0
            left += 1
```
##### 寻找重复数
```
    def findDuplicate(self, nums: List[int]) -> int:
        fast = nums[nums[0]]
        slow = nums[0]
        while slow != fast:
            fast = nums[nums[fast]]
            slow = nums[slow]
        fast = 0
        while slow != fast:
            fast = nums[fast]
            slow = nums[slow]
        return slow
```
##### 二叉树的序列化与反序列化
```
from collections import deque
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        res = []
        def se(root):
            if root == None:
                res.append("#")
                return
            res.append(str(root.val))
            se(root.left)
            se(root.right)
            return
        
        se(root)
        return ",".join(res)

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """

        def dese(data):
            rootVal = data.popleft()
            if rootVal == "#":
                return
            root = TreeNode(int(rootVal))
            root.left = dese(data)
            root.right = dese(data)
            return root

        data = data.split(",")
        data = deque(data)
        root = dese(data)
        return root
```
##### 最长递增子序列
```
    def lengthOfLIS(self, nums: List[int]) -> int:

        @cache
        def dp(i):
            if i == 0:
                return 1
            res = 1
            for j in range(i):
                if nums[j] < nums[i]:
                    res = max(res, dp(j) + 1)
            return res
        
        return max([dp(i) for i in range(len(nums))])


	def lengthOfLIS(self, nums: List[int]) -> int:
        top = [0 for _ in range(len(nums))]
        piles = 0
        for i in range(len(nums)):
            poker = nums[i]
            left, right = 0, piles - 1
            while left <= right:
                mid = (right + left) // 2
                if top[mid] == poker:
                    right = mid - 1
                elif top[mid] < poker:
                    left = mid + 1
                else:
                    right = mid - 1
            if left == piles:
                piles += 1
            top[left] = poker
        return piles
```
##### 删除无效的括号
```
    def removeInvalidParentheses(self, s: str) -> List[str]:
        self.res = []
        self.track = []
        self.backtrack(s, 0)

        maxLen = max([len(i) for i in self.res])
        res = set()
        for i in self.res:
            if len(i) == maxLen:
                res.add(i)
        return list(res)

    
    def backtrack(self, s, i):
        if i == len(s):
            if self.isValid("".join(self.track)):
                self.res.append("".join(self.track))
            return
        c = s[i]
        if c != '(' and c != ')':
            self.track.append(c)
            self.backtrack(s, i + 1)
            self.track.pop()
        else:
            self.track.append(c)
            self.backtrack(s, i + 1)
            self.track.pop()

            self.backtrack(s, i + 1)
        
    def isValid(self, s):
        left = 0
        for c in s:
            if c == '(':
                left += 1
            elif c == ')':
                left -= 1
                if left < 0:
                    return False
        return left == 0
```
##### 买卖股票的最佳时机含冷冻期
```
    def maxProfit(self, prices: List[int]) -> int:

        @cache
        def dp(i, status):
            if i >= len(prices):
                return 0
            if status:
                res = max(dp(i + 1, status), dp(i + 2, status ^ True) + prices[i])
                return res
            else:
                res = max(dp(i + 1, status), dp(i + 1, status ^ True) - prices[i])
                return res
            
        return dp(0, False)
```
##### 戳气球
```
    def maxCoins(self, nums: List[int]) -> int:

        arr = [1]
        arr.extend(nums)
        arr.append(1)

        @cache
        def dp(i, j):
            if i == j:
                return arr[i - 1] * arr[i] * arr[i + 1]
            res = max(dp(i + 1, j) + arr[i] * arr[i - 1] * arr[j + 1], dp(i, j - 1) + arr[j] * arr[i - 1] * arr[j + 1])
            for k in range(i + 1, j):
                res = max(dp(i, k - 1) + dp(k + 1, j) + arr[k] * arr[i - 1] * arr[j + 1], res)
            return res
        
        return dp(1, len(arr) - 2)
```
##### 零钱兑换
```
    def coinChange(self, coins: List[int], amount: int) -> int:

        @cache
        def dp(i, rest):
            if rest == 0:
                return 0
            if rest < 0:
                return float("inf")
            if i == len(coins):
                return float("inf")
            res = dp(i + 1, rest)
            if dp(i, rest - coins[i]) != float("inf"):
                res = min(res, dp(i, rest - coins[i]) + 1)
            return res
            
        res = dp(0, amount)
        return res if res != float("inf") else -1
```
##### 打家劫舍 III
```
    def rob(self, root: Optional[TreeNode]) -> int:

        @cache  
        def dp(root):
            if root == None:
                return 0
            p1 = dp(root.left) + dp(root.right)
            p2 = root.val
            if root.left != None:
                p2 += dp(root.left.left) + dp(root.left.right)
            if root.right != None:
                p2 += dp(root.right.left) + dp(root.right.right)
            return max(p1, p2)
        
        return dp(root)
```
##### 比特位计数
```
	奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。
	偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。

    def countBits(self, n: int) -> List[int]:
        res = [0] * (n + 1)
        for i in range(1, n + 1):
            if i % 2 == 0:
                res[i] = res[i//2]
            else:
                res[i] = res[i - 1] + 1
        return res
```
##### 前 K 个高频元素
```
from queue import PriorityQueue
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        freq = {}
        for num in nums:
            if num not in freq:
                freq[num] = 0
            freq[num] += 1
        pq = PriorityQueue()
        res = []
        for num, fre in freq.items():
            if len(pq.queue) == k:
                cur = pq.get()
                if fre >= cur.freq:
                    pq.put(Node(num, fre))
                else:
                    pq.put(cur)
            else:
                pq.put(Node(num, fre))
        while len(pq.queue) != 0:
            res.append(pq.get().num)
        return res


class Node:
    def __init__(self, num, freq):
        self.num = num
        self.freq = freq
    
    def __lt__(self, other):
        return self.freq < other.freq
```
##### 字符串解码
```
    def decodeString(self, s: str) -> str:
        return self.f(s, 0)[0]

    def f(self, s, i):
        res = ""
        count = 0
        while i < len(s) and s[i] != "]":
            if s[i].isdigit():
                count = count * 10 + int(s[i])
                i += 1
            elif s[i].isalpha():
                res += s[i]
                i += 1
            else:
                cur = self.f(s, i + 1)
                res += count * cur[0]
                count = 0
                i = cur[1] + 1
        return res, i
```
##### 根据身高重建队列
```
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        res = []
        people = sorted(people, key = lambda x: (-x[0], x[1]))
        for p in people:
            if len(res) <= p[1]:
                res.append(p)
            elif len(res) > p[1]:
                res.insert(p[1], p)
        return res
```
##### 分割等和子集
```
    def canPartition(self, nums: List[int]) -> bool:
        _sum = sum(nums)
        if _sum % 2 != 0:
            return False
        @cache
        def dp(i, rest):
            if rest == 0:
                return True
            if rest < 0:
                return False
            if i == len(nums):
                return False
            return dp(i + 1, rest) or dp(i + 1, rest - nums[i])
        
        return dp(0, _sum // 2)
```
##### 路径总和 III
```
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
    
        def process(x, target, pre, freq):
            if x == None:
                return 0
            cur = pre + x.val
            res = 0
            if cur - target in freq:
                res = freq[cur - target]
            if cur in freq:
                freq[cur] += 1
            else:
                freq[cur] = 1
            res += process(x.left, target, cur, freq)
            res += process(x.right, target, cur, freq)
            freq[cur] -= 1
            if freq[cur] == 0:
                freq.pop(cur)
            return res
        
        return process(root, targetSum, 0, {0: 1})
```
##### 找到字符串中所有字母异位词
```
    def findAnagrams(self, s: str, p: str) -> List[int]:
        res = []
        window = defaultdict(int)
        need = defaultdict(int)
        l = r = 0
        valid = 0
        for c in p:
            need[c] += 1
        while r < len(s):
            c = s[r]
            r += 1
            if c in need:
                window[c] += 1
                if window[c] == need[c]:
                    valid += 1
            while valid == len(need):
                if r - l == len(p):
                    res.append(l)
                d = s[l]
                l += 1
                if d in need:
                    if window[d] == need[d]:
                        valid -= 1
                    window[d] -= 1
        return res
```
##### 找到所有数组中消失的数字
```
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        def walk(i):
            while nums[i] != i + 1:
                nexti = nums[i] - 1
                if nums[nexti] == nexti + 1:
                    break
                nums[i], nums[nexti] = nums[nexti], nums[i]
        
        for i in range(len(nums)):
            walk(i)
        res = []
        for i in range(len(nums)):
            if nums[i] != i + 1:
                res.append(i + 1)
        return res
```
##### 汉明距离
```
    def hammingDistance(self, x: int, y: int) -> int:
        res = 0
        for i in range(31):
            x_i = x & (1 << i)
            y_i = y & (1 << i)
            if x_i != y_i:
                res += 1
        return res
```
##### 目标和
```
    def findTargetSumWays(self, nums: List[int], target: int) -> int:

        @cache
        def dp(i, total):
            if i == len(nums):
                return 1 if total == 0 else 0
            return dp(i + 1, total - nums[i]) + dp(i + 1, total + nums[i])
        
        return dp(0, target)
```
##### 把二叉搜索树转换为累加树
```
    def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        self.total = 0
        self.traverse(root)
        return root

    def traverse(self, x):
        if x == None:
            return
        self.traverse(x.right)
        self.total += x.val
        x.val = self.total 
        self.traverse(x.left)
```
##### 二叉树的直径
```
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        res = 0
        def traverse(x):
            if x == None:
                return 0
            nonlocal res
            left = traverse(x.left)
            right = traverse(x.right)
            cur = left + right
            res = max(res, cur)
            return max(left, right) + 1
        
        traverse(root)
        return res
```
##### 和为 K 的子数组
```
    def subarraySum(self, nums: List[int], k: int) -> int:
        preSum = defaultdict(int)
        preSum[0] = 1
        res = 0
        pre = 0
        for num in nums:
            cur = pre + num
            res += preSum[cur - k]
            preSum[cur] += 1
            pre = cur
        return res
```
##### 最短无序连续子数组
```
    def findUnsortedSubarray(self, nums: List[int]) -> int:
        lmax = nums[0]
        lflag = -1
        for idx, num in enumerate(nums[1:]):
            if lmax > num:
                lflag = idx + 1
            lmax = max(lmax, num)
        if lflag == -1:
            return 0
        rmin = nums[-1]
        rflag = len(nums) - 1
        for idx, num in enumerate(nums[-2::-1]):
            if rmin < num:
                rflag = len(nums) - idx - 2
            rmin = min(rmin, num)
        return lflag - rflag + 1
```
##### 合并二叉树
```
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:

        def traverse(x1, x2):
            if x1 == None and x2 == None:
                return None
            if x1 == None:
                return x2
            if x2 == None:
                return x1
            x1.val += x2.val
            x1.left = traverse(x1.left, x2.left)
            x1.right = traverse(x1.right, x2.right)
            return x1
        
        return traverse(root1, root2)
```
##### 任务调度器
```
from collections import defaultdict
class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        dic = defaultdict(int)
        for task in tasks:
            dic[task] += 1
        max_times = max(dic.values())
        max_item = 0
        for key, value in dic.items():
            if value == max_times:
                max_item += 1
        rest = len(tasks) - max_item * max_times
        res = max(n + 1, max_item) * (max_times - 1) + max_item
        if rest > max(n + 1 - max_item, 0) * (max_times - 1):
            res += rest - max(n + 1 - max_item, 0) * (max_times - 1)
        return res
```
##### 回文子串
```
    def countSubstrings(self, s: str) -> int:

        def find(i, j):
            size = 1 if i == j else 2 if s[i] == s[j] else 0
            if size == 0:
                return size
            i -= 1
            j += 1
            while i >= 0 and j < len(s):
                if s[i] == s[j]:
                    size += 2
                    i -= 1
                    j += 1
                else:
                    break
            return size
        res = 0
        for i in range(len(s)):
            res += find(i, i) // 2 + 1
        for i in range(len(s) - 1):
            res += find(i, i + 1) // 2
        return res
```
##### 每日温度
```
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        res = [0] * len(temperatures)
        stack = []
        for i in range(len(temperatures)):
            while len(stack) != 0 and temperatures[stack[-1]] < temperatures[i]:
                item = stack.pop()
                res[item] = i - item
            stack.append(i)
        return res
```
